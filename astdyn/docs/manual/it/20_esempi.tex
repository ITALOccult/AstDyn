\chapter{Esempi e Tutorial}
\label{ch:examples}

\section{Introduzione}

Questo capitolo fornisce tutorial passo-passo che dimostrano le capacit\`a di AstDyn. Tutti gli esempi includono codice completo e funzionante.

\subsection{Prerequisiti}

Verificare che AstDyn sia installato e configurato:

\begin{lstlisting}[language=bash]
# Compilare AstDyn
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j4

# Impostare percorso librerie
export LD_LIBRARY_PATH=/path/to/astdyn/lib:$LD_LIBRARY_PATH
\end{lstlisting}

\section{Esempio 1: Propagazione Orbitale Base}

\subsection{Obiettivo}

Propagare l'asteroide (203) Pompeja per 60 giorni usando modello di forza semplificato.

\subsection{Codice}

\begin{lstlisting}[language=C++,caption={esempio1\_propagazione.cpp}]
#include <astdyn/AstDyn.hpp>
#include <iostream>
#include <iomanip>

using namespace astdyn;

int main() {
    // Definire elementi kepleriani iniziali (Pompeja all'epoca JD 2460000.5)
    orbit::KeplerianElements elem0;
    elem0.a = 2.7436;                    // AU
    elem0.e = 0.0624;
    elem0.i = 11.74 * constants::DEG_TO_RAD;
    elem0.Omega = 339.86 * constants::DEG_TO_RAD;
    elem0.omega = 258.03 * constants::DEG_TO_RAD;
    elem0.M = 45.32 * constants::DEG_TO_RAD;
    elem0.epoch = 2460000.5;
    elem0.name = "Pompeja";
    
    std::cout << "Elementi Iniziali (Epoca " << std::fixed 
              << std::setprecision(1) << elem0.epoch << " JD):\n";
    std::cout << "  a     = " << std::setprecision(6) << elem0.a << " AU\n";
    std::cout << "  e     = " << elem0.e << "\n";
    std::cout << "  i     = " << std::setprecision(2) 
              << elem0.i * constants::RAD_TO_DEG << " deg\n";
    std::cout << "  Omega = " << elem0.Omega * constants::RAD_TO_DEG << " deg\n";
    std::cout << "  omega = " << elem0.omega * constants::RAD_TO_DEG << " deg\n";
    std::cout << "  M     = " << elem0.M * constants::RAD_TO_DEG << " deg\n";
    std::cout << "  Periodo = " << std::setprecision(1) 
              << elem0.period() << " giorni\n\n";
    
    // Convertire in coordinate cartesiane
    auto state0 = elem0.to_cartesian();
    std::cout << "Stato Cartesiano:\n";
    std::cout << "  Posizione: [" << std::setprecision(8)
              << state0.position[0] << ", "
              << state0.position[1] << ", "
              << state0.position[2] << "] AU\n";
    std::cout << "  Velocita': [" 
              << state0.velocity[0] << ", "
              << state0.velocity[1] << ", "
              << state0.velocity[2] << "] AU/giorno\n\n";
    
    // Configurare effemeridi (approssimazione analitica per semplicita')
    auto eph = std::make_shared<ephemeris::AnalyticEphemeris>();
    
    // Creare modello forze (Sole + Giove + Saturno)
    auto forces = std::make_shared<propagation::PointMassGravity>(
        eph, std::vector<std::string>{"JUPITER", "SATURN"});
    
    // Creare integratore (RKF78 con tolleranza 1e-12)
    auto integrator = std::make_shared<propagation::RKF78>(1e-12);
    
    // Creare propagatore
    propagation::Propagator prop(integrator, forces, eph);
    
    // Propagare per 60 giorni
    double target_epoch = elem0.epoch + 60.0;
    std::cout << "Propagazione a " << target_epoch << " JD (+60 giorni)...\n\n";
    
    auto state60 = prop.propagate(state0, target_epoch);
    
    // Riconvertire in kepleriani
    auto elem60 = orbit::KeplerianElements::from_cartesian(
        state60.position, state60.velocity, state60.epoch);
    
    std::cout << "Elementi Finali (Epoca " << elem60.epoch << " JD):\n";
    std::cout << "  a     = " << std::setprecision(6) << elem60.a << " AU\n";
    std::cout << "  e     = " << elem60.e << "\n";
    std::cout << "  i     = " << std::setprecision(2) 
              << elem60.i * constants::RAD_TO_DEG << " deg\n";
    std::cout << "  Omega = " << elem60.Omega * constants::RAD_TO_DEG << " deg\n";
    std::cout << "  omega = " << elem60.omega * constants::RAD_TO_DEG << " deg\n";
    std::cout << "  M     = " << elem60.M * constants::RAD_TO_DEG << " deg\n\n";
    
    // Calcolare variazioni
    std::cout << "Variazioni in 60 giorni:\n";
    std::cout << "  Delta a     = " << std::scientific << std::setprecision(2)
              << (elem60.a - elem0.a) << " AU\n";
    std::cout << "  Delta e     = " << (elem60.e - elem0.e) << "\n";
    std::cout << "  Delta i     = " << std::fixed << std::setprecision(4)
              << (elem60.i - elem0.i) * constants::RAD_TO_DEG * 3600.0 
              << " arcsec\n";
    std::cout << "  Delta Omega = " 
              << (elem60.Omega - elem0.Omega) * constants::RAD_TO_DEG * 3600.0
              << " arcsec\n";
    
    std::cout << "\nStatistiche Integrazione:\n";
    std::cout << "  Passi eseguiti: " << integrator->steps_taken() << "\n";
    std::cout << "  Passi rigettati: " << integrator->steps_rejected() << "\n";
    
    return 0;
}
\end{lstlisting}

\subsection{Compilazione}

\begin{lstlisting}[language=bash]
g++ -std=c++17 -O3 esempio1_propagazione.cpp -o esempio1 \
    -I/path/to/astdyn/include \
    -L/path/to/astdyn/lib -lastdyn \
    -lboost_system
\end{lstlisting}

\subsection{Output Atteso}

\begin{verbatim}
Elementi Iniziali (Epoca 2460000.5 JD):
  a     = 2.743600 AU
  e     = 0.062400
  i     = 11.74 deg
  Omega = 339.86 deg
  omega = 258.03 deg
  M     = 45.32 deg
  Periodo = 1656.3 giorni

Propagazione a 2460060.5 JD (+60 giorni)...

Elementi Finali (Epoca 2460060.5 JD):
  a     = 2.743598 AU
  e     = 0.062401
  i     = 11.74 deg
  ...

Variazioni in 60 giorni:
  Delta a     = -2.14e-06 AU
  Delta e     = 1.23e-06
  Delta i     = 0.0234 arcsec
  Delta Omega = 0.1456 arcsec

Statistiche Integrazione:
  Passi eseguiti: 127
  Passi rigettati: 3
\end{verbatim}

\section{Esempio 2: Generazione Effemeridi}

\subsection{Obiettivo}

Generare effemeridi giornaliere per 30 giorni e scrivere su file.

\subsection{Codice}

\begin{lstlisting}[language=C++,caption={esempio2\_effemeridi.cpp}]
#include <astdyn/AstDyn.hpp>
#include <fstream>
#include <iomanip>

using namespace astdyn;

int main() {
    // Elementi iniziali
    orbit::KeplerianElements elem;
    elem.a = 2.7436;
    elem.e = 0.0624;
    elem.i = 11.74 * constants::DEG_TO_RAD;
    elem.Omega = 339.86 * constants::DEG_TO_RAD;
    elem.omega = 258.03 * constants::DEG_TO_RAD;
    elem.M = 45.32 * constants::DEG_TO_RAD;
    elem.epoch = 2460000.5;
    
    // Configurare propagatore
    auto eph = std::make_shared<ephemeris::AnalyticEphemeris>();
    auto forces = std::make_shared<propagation::PointMassGravity>(
        eph, std::vector<std::string>{"JUPITER", "SATURN", "EARTH"});
    auto integrator = std::make_shared<propagation::RKF78>(1e-12);
    propagation::Propagator prop(integrator, forces, eph);
    
    // Generare effemeridi
    auto state0 = elem.to_cartesian();
    double start = elem.epoch;
    double end = elem.epoch + 30.0;
    double step = 1.0;  // Giornaliero
    
    auto ephemeris = prop.generate_ephemeris(state0, start, end, step);
    
    // Scrivere su file
    std::ofstream outfile("pompeja_effemeridi.txt");
    outfile << std::fixed << std::setprecision(6);
    outfile << "# Effemeridi per Pompeja\n";
    outfile << "# Epoca (JD)      X (AU)        Y (AU)        Z (AU)        "
            << "VX (AU/d)     VY (AU/d)     VZ (AU/d)\n";
    
    for (const auto& state : ephemeris) {
        outfile << std::setw(14) << state.epoch << "  "
                << std::setw(12) << state.position[0] << "  "
                << std::setw(12) << state.position[1] << "  "
                << std::setw(12) << state.position[2] << "  "
                << std::setw(12) << state.velocity[0] << "  "
                << std::setw(12) << state.velocity[1] << "  "
                << std::setw(12) << state.velocity[2] << "\n";
    }
    
    outfile.close();
    std::cout << "Effemeridi scritte in pompeja_effemeridi.txt\n";
    std::cout << "Generati " << ephemeris.size() << " stati\n";
    
    return 0;
}
\end{lstlisting}

\section{Esempio 3: Determinazione Orbitale}

\subsection{Obiettivo}

Determinare orbita da osservazioni sintetiche usando correzione differenziale.

\subsection{Codice}

\begin{lstlisting}[language=C++,caption={esempio3\_determinazione\_orbitale.cpp}]
#include <astdyn/AstDyn.hpp>
#include <iostream>
#include <iomanip>
#include <random>

using namespace astdyn;

int main() {
    // Elementi veri (quelli da recuperare)
    orbit::KeplerianElements true_elem;
    true_elem.a = 2.7436;
    true_elem.e = 0.0624;
    true_elem.i = 11.74 * constants::DEG_TO_RAD;
    true_elem.Omega = 339.86 * constants::DEG_TO_RAD;
    true_elem.omega = 258.03 * constants::DEG_TO_RAD;
    true_elem.M = 45.32 * constants::DEG_TO_RAD;
    true_elem.epoch = 2460000.5;
    
    // Generare osservazioni sintetiche
    auto eph = std::make_shared<ephemeris::AnalyticEphemeris>();
    auto forces = std::make_shared<propagation::PointMassGravity>(
        eph, std::vector<std::string>{"JUPITER", "SATURN"});
    auto integrator = std::make_shared<propagation::RKF78>(1e-12);
    propagation::Propagator prop(integrator, forces, eph);
    
    // Osservatorio (Pan-STARRS F51)
    observations::ObservatoryCoordinates obs_coord;
    obs_coord.code = "F51";
    obs_coord.longitude = -156.2569 * constants::DEG_TO_RAD;
    obs_coord.latitude = 20.7082 * constants::DEG_TO_RAD;
    obs_coord.altitude = 3055.0;
    
    std::vector<observations::Observation> observations;
    std::random_device rd;
    std::mt19937 gen(rd());
    std::normal_distribution<> noise(0.0, 0.5 * constants::ARCSEC_TO_RAD);
    
    // Generare 10 osservazioni in 60 giorni
    auto state0 = true_elem.to_cartesian();
    for (int i = 0; i < 10; ++i) {
        double t = true_elem.epoch + i * 6.0;  // Ogni 6 giorni
        auto state = prop.propagate(state0, t);
        
        // Posizione osservatore
        Vector3d obs_pos = obs_coord.position_icrf(t);
        
        // Posizione topocentrica
        Vector3d topo = state.position - obs_pos;
        double range = topo.norm();
        
        // Convertire in AR/Dec
        double ra = std::atan2(topo[1], topo[0]);
        double dec = std::asin(topo[2] / range);
        
        // Aggiungere rumore
        ra += noise(gen);
        dec += noise(gen);
        
        observations::Observation obs;
        obs.epoch = t;
        obs.ra = ra;
        obs.dec = dec;
        obs.sigma_ra = 0.5 * constants::ARCSEC_TO_RAD;
        obs.sigma_dec = 0.5 * constants::ARCSEC_TO_RAD;
        obs.obs_code = "F51";
        
        observations.push_back(obs);
    }
    
    std::cout << "Generate " << observations.size() 
              << " osservazioni sintetiche\n\n";
    
    // Guess iniziale (elementi veri perturbati)
    orbit::KeplerianElements initial_guess = true_elem;
    initial_guess.a += 0.001;  // +0.001 AU errore
    initial_guess.e += 0.002;  // +0.002 errore eccentricita'
    
    std::cout << "Guess Iniziale:\n";
    std::cout << "  a = " << std::setprecision(6) << initial_guess.a << " AU\n";
    std::cout << "  e = " << initial_guess.e << "\n\n";
    
    // Correzione differenziale
    orbit_determination::DifferentialCorrector dc(
        std::make_shared<propagation::Propagator>(integrator, forces, eph),
        20, 1e-8);
    
    auto result = dc.solve(initial_guess, observations, 
                          std::vector{obs_coord});
    
    // Risultati
    std::cout << "Risultati Correzione Differenziale:\n";
    std::cout << "  Convergenza: " << (result.converged ? "Si'" : "No") << "\n";
    std::cout << "  Iterazioni: " << result.iterations << "\n";
    std::cout << "  RMS Residui: " << std::setprecision(3) 
              << result.rms_residual << " arcsec\n\n";
    
    std::cout << "Elementi Recuperati:\n";
    std::cout << "  a = " << std::setprecision(6) << result.elements.a 
              << " AU (errore: " << std::scientific << std::setprecision(2)
              << (result.elements.a - true_elem.a) << ")\n";
    std::cout << "  e = " << std::fixed << std::setprecision(6) 
              << result.elements.e 
              << " (errore: " << std::scientific 
              << (result.elements.e - true_elem.e) << ")\n";
    
    return 0;
}
\end{lstlisting}

\section{Esempio 4: Lettura Osservazioni MPC}

\subsection{Obiettivo}

Leggere file osservazioni MPC reale e calcolare residui.

\subsection{Codice}

\begin{lstlisting}[language=C++,caption={esempio4\_parser\_mpc.cpp}]
#include <astdyn/AstDyn.hpp>
#include <iostream>
#include <iomanip>

using namespace astdyn;

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Uso: " << argv[0] << " <osservazioni.txt>\n";
        return 1;
    }
    
    // Leggere osservazioni MPC
    std::string filename = argv[1];
    auto observations = io::MPCReader::read_file(filename);
    
    std::cout << "Caricate " << observations.size() << " osservazioni\n";
    std::cout << "Intervallo temporale: " << std::fixed << std::setprecision(1)
              << (observations.back().epoch - observations.front().epoch)
              << " giorni\n\n";
    
    // Mostrare prime 5 osservazioni
    std::cout << "Prime 5 osservazioni:\n";
    std::cout << "Epoca (JD)       AR (deg)      Dec (deg)     Cod.Oss\n";
    
    for (size_t i = 0; i < std::min<size_t>(5, observations.size()); ++i) {
        const auto& obs = observations[i];
        std::cout << std::setw(14) << std::setprecision(5) << obs.epoch << "  "
                  << std::setw(12) << std::setprecision(6) 
                  << obs.ra * constants::RAD_TO_DEG << "  "
                  << std::setw(12) << obs.dec * constants::RAD_TO_DEG << "  "
                  << obs.obs_code << "\n";
    }
    
    // Contare osservazioni per osservatorio
    std::map<std::string, int> obs_counts;
    for (const auto& obs : observations) {
        obs_counts[obs.obs_code]++;
    }
    
    std::cout << "\nOsservazioni per osservatorio:\n";
    for (const auto& [code, count] : obs_counts) {
        std::cout << "  " << code << ": " << count << "\n";
    }
    
    return 0;
}
\end{lstlisting}

\section{Esempio 5: Matrice Transizione Stato}

\subsection{Obiettivo}

Propagare orbita con STM e analizzare sensibilita' a condizioni iniziali.

\subsection{Codice}

\begin{lstlisting}[language=C++,caption={esempio5\_stm.cpp}]
#include <astdyn/AstDyn.hpp>
#include <iostream>
#include <iomanip>

using namespace astdyn;

int main() {
    // Elementi iniziali
    orbit::KeplerianElements elem;
    elem.a = 2.7436;
    elem.e = 0.0624;
    elem.i = 11.74 * constants::DEG_TO_RAD;
    elem.Omega = 339.86 * constants::DEG_TO_RAD;
    elem.omega = 258.03 * constants::DEG_TO_RAD;
    elem.M = 45.32 * constants::DEG_TO_RAD;
    elem.epoch = 2460000.5;
    
    // Configurare propagatore
    auto eph = std::make_shared<ephemeris::AnalyticEphemeris>();
    auto forces = std::make_shared<propagation::PointMassGravity>(
        eph, std::vector<std::string>{"JUPITER", "SATURN"});
    auto integrator = std::make_shared<propagation::RKF78>(1e-12);
    propagation::Propagator prop(integrator, forces, eph);
    
    // Propagare con STM
    auto state0 = elem.to_cartesian();
    double target = elem.epoch + 60.0;
    
    auto [state60, stm] = prop.propagate_with_stm(state0, target);
    
    std::cout << "Matrice Transizione Stato dopo 60 giorni:\n";
    std::cout << std::scientific << std::setprecision(4);
    
    for (int i = 0; i < 6; ++i) {
        for (int j = 0; j < 6; ++j) {
            std::cout << std::setw(12) << stm(i, j) << " ";
        }
        std::cout << "\n";
    }
    
    // Calcolare sensibilita'
    std::cout << "\nAnalisi Sensibilita':\n";
    std::cout << "Errore posizione iniziale: 1 km in X\n";
    
    Vector6d delta_x0;
    delta_x0.setZero();
    delta_x0(0) = 1.0 / constants::AU;  // 1 km = 1/AU_km AU
    
    Vector6d delta_xf = stm * delta_x0;
    
    std::cout << "Errore posizione finale:\n";
    std::cout << "  Delta X: " << delta_xf(0) * constants::AU << " km\n";
    std::cout << "  Delta Y: " << delta_xf(1) * constants::AU << " km\n";
    std::cout << "  Delta Z: " << delta_xf(2) * constants::AU << " km\n";
    
    double pos_error = delta_xf.head<3>().norm() * constants::AU;
    std::cout << "  Totale: " << std::setprecision(2) << pos_error << " km\n";
    
    return 0;
}
\end{lstlisting}

\section{Esempio 6: Modello Forza Personalizzato}

\subsection{Obiettivo}

Implementare e usare modello forza personalizzato per pressione radiativa.

\subsection{Codice}

\begin{lstlisting}[language=C++,caption={esempio6\_forza\_personalizzata.cpp}]
#include <astdyn/AstDyn.hpp>
#include <iostream>

using namespace astdyn;

// Modello forza personalizzato: Pressione radiazione solare
class SolarRadiationPressure : public propagation::ForceModel {
public:
    SolarRadiationPressure(double area_mass_ratio, double reflectivity = 1.0)
        : area_mass_ratio_(area_mass_ratio), reflectivity_(reflectivity) {}
    
    Vector3d acceleration(double t, const Vector3d& pos, 
                         const Vector3d& vel) const override {
        // Costante pressione radiazione solare
        const double P_sun = 4.56e-6;  // N/m^2 a 1 AU
        
        // Distanza dal Sole
        double r = pos.norm();
        
        // Accelerazione pressione radiativa (lontano dal Sole)
        Vector3d acc = (P_sun * area_mass_ratio_ * reflectivity_ / (r * r)) 
                      * pos.normalized();
        
        return acc;
    }
    
private:
    double area_mass_ratio_;  // m^2/kg
    double reflectivity_;
};

int main() {
    orbit::KeplerianElements elem;
    elem.a = 2.7436;
    elem.e = 0.0624;
    elem.i = 11.74 * constants::DEG_TO_RAD;
    elem.Omega = 339.86 * constants::DEG_TO_RAD;
    elem.omega = 258.03 * constants::DEG_TO_RAD;
    elem.M = 45.32 * constants::DEG_TO_RAD;
    elem.epoch = 2460000.5;
    
    // Configurare effemeridi
    auto eph = std::make_shared<ephemeris::AnalyticEphemeris>();
    
    // Modello forze combinato: Gravita' + Pressione Radiativa
    auto gravity = std::make_shared<propagation::PointMassGravity>(
        eph, std::vector<std::string>{"JUPITER", "SATURN"});
    
    auto radiation = std::make_shared<SolarRadiationPressure>(0.01);  // 0.01 m^2/kg
    
    auto combined = std::make_shared<propagation::CombinedForceModel>();
    combined->add_force(gravity);
    combined->add_force(radiation);
    
    // Propagare
    auto integrator = std::make_shared<propagation::RKF78>(1e-12);
    propagation::Propagator prop(integrator, combined, eph);
    
    auto state0 = elem.to_cartesian();
    auto state60 = prop.propagate(state0, elem0.epoch + 60.0);
    
    std::cout << "Propagazione con modello pressione radiativa completata\n";
    
    return 0;
}
\end{lstlisting}

\section{Compilazione ed Esecuzione Esempi}

\subsection{CMakeLists.txt}

\begin{lstlisting}[caption={CMakeLists.txt per esempi}]
cmake_minimum_required(VERSION 3.12)
project(EsempiAstDyn)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Trovare AstDyn
find_package(AstDyn REQUIRED)
find_package(Eigen3 REQUIRED)

# Eseguibili esempi
add_executable(esempio1 esempio1_propagazione.cpp)
target_link_libraries(esempio1 AstDyn::astdyn Eigen3::Eigen)

add_executable(esempio2 esempio2_effemeridi.cpp)
target_link_libraries(esempio2 AstDyn::astdyn Eigen3::Eigen)

add_executable(esempio3 esempio3_determinazione_orbitale.cpp)
target_link_libraries(esempio3 AstDyn::astdyn Eigen3::Eigen)

add_executable(esempio4 esempio4_parser_mpc.cpp)
target_link_libraries(esempio4 AstDyn::astdyn Eigen3::Eigen)

add_executable(esempio5 esempio5_stm.cpp)
target_link_libraries(esempio5 AstDyn::astdyn Eigen3::Eigen)

add_executable(esempio6 esempio6_forza_personalizzata.cpp)
target_link_libraries(esempio6 AstDyn::astdyn Eigen3::Eigen)
\end{lstlisting}

\subsection{Comandi Compilazione}

\begin{lstlisting}[language=bash]
mkdir build && cd build
cmake ..
make -j4

# Eseguire esempi
./esempio1
./esempio2
./esempio3
./esempio4 ../data/osservazioni.txt
./esempio5
./esempio6
\end{lstlisting}

\section{Sommario}

Questo capitolo ha dimostrato:

\begin{enumerate}
    \item \textbf{Propagazione base}: Conversione elementi, configurazione propagatore, integrazione equazioni
    \item \textbf{Generazione effemeridi}: Creazione tabelle di stati
    \item \textbf{Determinazione orbitale}: Correzione differenziale con osservazioni sintetiche
    \item \textbf{Parsing MPC}: Lettura file osservazioni reali
    \item \textbf{Propagazione STM}: Analisi sensibilita'
    \item \textbf{Forze personalizzate}: Estensione framework modelli forza
\end{enumerate}

Tutti gli esempi sono pronti per uso produttivo e possono essere adattati per applicazioni reali.
